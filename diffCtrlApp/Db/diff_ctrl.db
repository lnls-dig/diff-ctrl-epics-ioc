######################################################################
#
#            Position Difference Control App Database
#
# Desc: These records provide an abstraction layer for two
# motor applications that control the difference between
# the position of two edges, such as scrapers and slits.
#
#####################################################################

#####################################################################
# LOW LEVEL IOCs INFO
#
# Desc: Records providing information regarding the motion
# controllers IOCs.

record(stringout, "$(P)$(R)NegativeMotionCtrl-Cte"){
  field(DESC, "Motion controller for neg side name")
  field(VAL, "$(CTRL_NEG)")
}

record(stringout, "$(P)$(R)PositiveMotionCtrl-Cte"){
  field(DESC, "Motion controller for pos side name")
  field(VAL, "$(CTRL_POS)")
}

#####################################################################
# CALIBRATION
#
# Desc: Records for slit/scraper position calibration.

# Allow manual adjust of center and width,
# without moving any edges
record(bo, "$(P)$(R)SetMode-Sel"){
  field(DESC, "Set mode for center and width")
  field(ZNAM, "Move")
  field(ONAM, "Calibrate")
  field(FLNK, "$(P)$(R)SetModeSeq")
}

# Sequence of operations to configure mode
record(seq, "$(P)$(R)SetModeSeq"){
  field(DESC, "Setting mode config sequence")
  field(SELM, "All")
  field(DOL1, "$(P)$(R)SetMode-Sel")
  field(DOL2, "$(P)$(R)SetMode-Sel")
  field(LNK1, "$(CTRL_NEG)Mtr.SET PP")               # 0 -> Use, 1 -> Set
  field(LNK2, "$(CTRL_POS)Mtr.SET PP")              # 0 -> Use, 1 -> Set
  field(FLNK, "$(P)$(R)SetMode-Sts")
}

# Set mode status
record(bi, "$(P)$(R)SetMode-Sts"){
  field(DESC, "Set mode for center and width status")
  field(ZNAM, "Move")
  field(ONAM, "Calibrate")
  field(INP, "$(P)$(R)SetMode-Sel")
}

# Start homing of both window sides cmd
record(bo, "$(P)$(R)Home-Cmd"){
  field(DESC, "Home both edges")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)HomeSeq")
}

# Slit/Scraper homing sequece
record(seq, "$(P)$(R)HomeSeq"){
  field(DESC, "Homing sequence")
  field(SELM, "All")
  field(DOL1, "$(P)$(R)Home-Cmd")
  field(DOL2, "$(P)$(R)Home-Cmd")
  field(LNK1, "$(CTRL_NEG)HomeToLimSw-Cmd")
  field(LNK2, "$(CTRL_POS)HomeToLimSw-Cmd")
}

#####################################################################
# SLIT MOTION CONTROL
#
# Desc: Slit motion control main parameters.

# Position of slit/scraper negative edge
record(ao, "$(P)$(R)NegativeEdgePos-SP"){
  field(DESC, "Negative edge position")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(DRVH, "1000000")                              # Temporary setting, only for startup
  field(DRVL, "-1000000")                             # Temporary setting, only for startup
  field(OUT, "$(P)$(R)CoordinateConv.A PP")
}

# Position of slit/scraper pos edge
record(ao, "$(P)$(R)PositiveEdgePos-SP"){
  field(DESC, "Positive edge position")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(DRVH, "1000000")                              # Temporary setting, only for startup
  field(DRVL, "-1000000")                             # Temporary setting, only for startup
  field(OUT, "$(P)$(R)CoordinateConv.B PP")
}

# Slit center
record(ao, "$(P)$(R)Center-SP"){
  field(DESC, "Slit center")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(OUT, "$(P)$(R)CoordinateConv.C PP")
}

# Slit width
record(ao, "$(P)$(R)Width-SP"){
  field(DESC, "Slit width")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(DRVH, "500")                                  # High limit is set here only to enable low limit
  field(DRVL, "0")                                    # Width cannot be negative
  field(OUT, "$(P)$(R)CoordinateConv.D PP")
}

# Convert coordinates
record(transform, "$(P)$(R)CoordinateConv"){
  field(DESC, "Coordinate converter")
  field(COPT, "Conditional")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
# ----- Inputs -----
# Do not use input links, so that it
# can operate in Conditional mode
# ----- Create synonyms -----
  field(CMTA, "$neg")
  field(CMTB, "$pos")
  field(CMTC, "$center")
  field(CMTD, "$width")
# ----- Conversion expressions -----
  field(CLCA, "$center-$width/2")                     # Virtual neg edge position
  field(CLCB, "$center+$width/2")                     # Virtual pos edge position
  field(CLCC, "($neg+$pos)/2")                     # Center position
  field(CLCD, "$pos-$neg")                         # Width of slit/scraper window
# ----- Outputs -----
  field(OUTA, "$(CTRL_NEG)AbsPos-SP")
  field(FLNK, "$(P)$(R)RevPositivePos")                  # Postpone pos edge move
}

# Reverse pos edge commanded position
record(calcout, "$(P)$(R)RevPositivePos"){
  field(DESC, "Reverse pos edge commanded pos")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(INPA, "$(P)$(R)CoordinateConv.B")             # Get pos edge position independently of how it was updated
  field(CALC, "-A")                                   # Positive edge reference frame is reverse
  field(OUT, "$(CTRL_POS)AbsPos-SP")
}

# Slit neg edge position readback
record(ai, "$(P)$(R)NegativeEdgePos-RB"){
  field(DESC, "Negative edge position RB")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(CTRL_NEG)EncPos-Mon CPP")            # Get position from encoder
  field(FLNK, "$(P)$(R)Center-RB")
}

# Reverse pos edge position readback sign
record(calc, "$(P)$(R)RevPositivePosRB"){
  field(DESC, "Reverse pos edge encoder reading")
  field(INPA, "$(CTRL_POS)EncPos-Mon CPP")          # Get position from encoder
  field(CALC, "-A")
  field(FLNK, "$(P)$(R)PositiveEdgePos-RB")
}

# Slit pos edge position readback
record(ai, "$(P)$(R)PositiveEdgePos-RB"){
  field(DESC, "Positive edge position RB")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(P)$(R)RevPositivePosRB")                 # Get reversed encoder position
  field(FLNK, "$(P)$(R)Center-RB")
}

# Slit center readback
record(calc, "$(P)$(R)Center-RB"){
  field(DESC, "Slit center RB")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(INPA, "$(P)$(R)NegativeEdgePos-RB")
  field(INPB, "$(P)$(R)PositiveEdgePos-RB")
  field(CALC, "(A+B)/2")                              # Calculate center from readback values
  field(FLNK, "$(P)$(R)Width-RB")
}

# Slit width readback
record(calc, "$(P)$(R)Width-RB"){
  field(DESC, "Slit width RB")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")  
  field(INPA, "$(P)$(R)NegativeEdgePos-RB")
  field(INPB, "$(P)$(R)PositiveEdgePos-RB")
  field(CALC, "B-A")
}

#####################################################################
# LIMIT PROTECTION
#
# Desc: Protect the slit edges from hitting each other.

# Limit neg edge motion
record(calcout, "$(P)$(R)NegativeEdgeProtect"){
  field(DESC, "Auto set protection limit for neg edge")
  field(INPA, "$(P)$(R)PositiveEdgePos-RB CPP")          # Read pos edge position
  field(CALC, "A")
  field(OUT, "$(P)$(R)NegativeEdgePos-SP.DRVH")           # Set neg edge high limit, without processing
  field(DISV, "0")                                    # Record remains disabled until initialization enables it
}

# Limit pos edge motion
record(calcout, "$(P)$(R)PositiveEdgeProtect"){
  field(DESC, "Auto set protection limit for pos edge")
  field(INPA, "$(P)$(R)NegativeEdgePos-RB CPP")           # Read neg edge position
  field(CALC, "A")
  field(OUT, "$(P)$(R)PositiveEdgePos-SP.DRVL")          # Set pos edge low limit, without processing
  field(DISV, "0")                                    # Record remains disabled until initialization enables it
}

# Keep the speed of both motors the same
# so they do not hit each other
record(calcout, "$(P)$(R)SpeedProtect"){
  field(DESC, "Keep both motors with same speed")
  field(PINI, "YES")
  field(INPA, "$(CTRL_NEG)Mtr.VELO CPP")
  field(INPB, "$(CTRL_POS)Mtr.VELO CPP")
  field(CALC, "B#A")
  field(OCAL, "A")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(CTRL_POS)Mtr.VELO PP")              # Set pos motor speed equal to neg motor speed
}

# Keep the max speed of both motors the same
# so that their speed can be set automatically
record(calcout, "$(P)$(R)MaxSpeedProtect"){
  field(DESC, "Keep both motors with same max speed")
  field(PINI, "YES")
  field(INPA, "$(CTRL_NEG)Mtr.VMAX CPP")
  field(INPB, "$(CTRL_POS)Mtr.VMAX CPP")
  field(CALC, "B#A")
  field(OCAL, "A")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(CTRL_POS)Mtr.VMAX PP")              # Set pos motor max speed equal to neg motor max speed
}

# Keep the acceleration of both motors the same
# so they do not hit each other
record(calcout, "$(P)$(R)AccProtect"){
  field(DESC, "Keep both motors with same acceleration")
  field(PINI, "YES")
  field(INPA, "$(CTRL_NEG)Mtr.ACCL CPP")
  field(INPB, "$(CTRL_POS)Mtr.ACCL CPP")
  field(CALC, "B#A")
  field(OCAL, "A")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(CTRL_POS)Mtr.ACCL PP")              # Set pos motor acceleration equal to neg motor acceleration
}

#####################################################################
# POSITION TWEAKING
#
# Desc: Records to allow position tweaking. These records make use
#       of the records defined in the SLIT MOTION CONTROL section.

# Step for pos edge pos increment
record(ao, "$(P)$(R)PositiveEdgeStep-SP"){
  field(DESC, "Step for pos edge increment")
  field(PINI, "YES")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(VAL, "1")
  field(FLNK, "$(P)$(R)PositiveEdgeStep-RB")
}

# Step for pos edge pos increment RB
record(ai, "$(P)$(R)PositiveEdgeStep-RB"){
  field(DESC, "Step for pos edge increment RB")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(P)$(R)PositiveEdgeStep-SP")
}

# Step for neg edge pos increment
record(ao, "$(P)$(R)NegativeEdgeStep-SP"){
  field(DESC, "Step for neg edge increment")
  field(PINI, "YES")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(VAL, "1")
  field(FLNK, "$(P)$(R)NegativeEdgeStep-RB")
}

# Step for neg edge pos increment RB
record(ai, "$(P)$(R)NegativeEdgeStep-RB"){
  field(DESC, "Step for neg edge increment RB")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(P)$(R)NegativeEdgeStep-SP")
}

# Step for center pos increment
record(ao, "$(P)$(R)CenterStep-SP"){
  field(DESC, "Step for center pos increment")
  field(PINI, "YES")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(VAL, "1")
  field(FLNK, "$(P)$(R)CenterStep-RB")
}

# Step for center pos increment RB
record(ai, "$(P)$(R)CenterStep-RB"){
  field(DESC, "Step for center pos increment RB")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(P)$(R)CenterStep-SP")
}

# Step for width increment
record(ao, "$(P)$(R)WidthStep-SP"){
  field(DESC, "Step for width increment")
  field(PINI, "YES")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(VAL, "1")
  field(FLNK, "$(P)$(R)WidthStep-RB")
}

# Step for width increment RB
record(ai, "$(P)$(R)WidthStep-RB"){
  field(DESC, "Step for width increment RB")
  field(PREC, "$(PREC)")
  field(EGU, "$(EGU)")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(P)$(R)WidthStep-SP")
}

# Increment pos edge pos by step
record(bo, "$(P)$(R)IncPositiveEdge-Cmd"){
  field(DESC, "Increment pos edge pos by defined step")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)IncPositiveEdgeCalc")
}

# Calc to increment pos edge position
record(calcout, "$(P)$(R)IncPositiveEdgeCalc"){
  field(DESC, "Increment pos edge by step calc")
  field(INPA, "$(P)$(R)IncPositiveEdge-Cmd")
  field(INPB, "$(P)$(R)PositiveEdgeStep-RB")
  field(INPC, "$(P)$(R)PositiveEdgePos-RB")
  field(INPD, "$(CTRL_NEG)Mtr.DMOV")
  field(INPE, "$(CTRL_POS)Mtr.DMOV")
  field(CALC, "A&&D&&E")                                 # Increment command 'on' and motors not moving
  field(OCAL, "C+B")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)PositiveEdgePos-SP PP")
}

# Decrement pos edge pos by step
record(bo, "$(P)$(R)DecPositiveEdge-Cmd"){
  field(DESC, "Decrement pos edge pos by defined step")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)DecPositiveEdgeCalc")
}

# Calc to decrement pos edge position
record(calcout, "$(P)$(R)DecPositiveEdgeCalc"){
  field(DESC, "Decrement pos edge by step calc")
  field(INPA, "$(P)$(R)DecPositiveEdge-Cmd")
  field(INPB, "$(P)$(R)PositiveEdgeStep-RB")
  field(INPC, "$(P)$(R)PositiveEdgePos-RB")
  field(INPD, "$(CTRL_NEG)Mtr.DMOV")
  field(INPE, "$(CTRL_POS)Mtr.DMOV")
  field(CALC, "A&&D&&E")                                 # Decrement command 'on' and motors not moving
  field(OCAL, "C-B")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)PositiveEdgePos-SP PP")
}

# Increment neg edge pos by step
record(bo, "$(P)$(R)IncNegativeEdge-Cmd"){
  field(DESC, "Increment neg edge pos by defined step")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)IncNegativeEdgeCalc")
}

# Calc to increment neg edge position
record(calcout, "$(P)$(R)IncNegativeEdgeCalc"){
  field(DESC, "Increment neg edge by step calc")
  field(INPA, "$(P)$(R)IncNegativeEdge-Cmd")
  field(INPB, "$(P)$(R)NegativeEdgeStep-RB")
  field(INPC, "$(P)$(R)NegativeEdgePos-RB")
  field(INPD, "$(CTRL_NEG)Mtr.DMOV")
  field(INPE, "$(CTRL_POS)Mtr.DMOV")
  field(CALC, "A&&D&&E")                                 # Increment command 'on' and motors not moving
  field(OCAL, "C+B")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)NegativeEdgePos-SP PP")
}

# Decrement neg edge pos by step
record(bo, "$(P)$(R)DecNegativeEdge-Cmd"){
  field(DESC, "Decrement neg edge pos by defined step")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)DecNegativeEdgeCalc")
}

# Calc to decrement neg edge position
record(calcout, "$(P)$(R)DecNegativeEdgeCalc"){
  field(DESC, "Decrement neg edge by step calc")
  field(INPA, "$(P)$(R)DecNegativeEdge-Cmd")
  field(INPB, "$(P)$(R)NegativeEdgeStep-RB")
  field(INPC, "$(P)$(R)NegativeEdgePos-RB")
  field(INPD, "$(CTRL_NEG)Mtr.DMOV")
  field(INPE, "$(CTRL_POS)Mtr.DMOV")
  field(CALC, "A&&D&&E")                                 # Decrement command 'on' and motors not moving
  field(OCAL, "C-B")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)NegativeEdgePos-SP PP")
}

# Increment center pos by step
record(bo, "$(P)$(R)IncCenter-Cmd"){
  field(DESC, "Increment center pos by defined step")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)IncCenterCalc")
}

# Calc to increment center position
record(calcout, "$(P)$(R)IncCenterCalc"){
  field(DESC, "Increment center pos by step calc")
  field(INPA, "$(P)$(R)IncCenter-Cmd")
  field(INPB, "$(P)$(R)CenterStep-RB")
  field(INPC, "$(P)$(R)Center-RB")
  field(INPD, "$(CTRL_NEG)Mtr.DMOV")
  field(INPE, "$(CTRL_POS)Mtr.DMOV")
  field(CALC, "A&&D&&E")                                 # Increment command 'on' and motors not moving
  field(OCAL, "C+B")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)Center-SP PP")
}

# Decrement center pos by step
record(bo, "$(P)$(R)DecCenter-Cmd"){
  field(DESC, "Decrement center pos by defined step")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)DecCenterCalc")
}

# Calc to decrement center position
record(calcout, "$(P)$(R)DecCenterCalc"){
  field(DESC, "Decrement center pos by step calc")
  field(INPA, "$(P)$(R)DecCenter-Cmd")
  field(INPB, "$(P)$(R)CenterStep-RB")
  field(INPC, "$(P)$(R)Center-RB")
  field(INPD, "$(CTRL_NEG)Mtr.DMOV")
  field(INPE, "$(CTRL_POS)Mtr.DMOV")
  field(CALC, "A&&D&&E")                                 # Decrement command 'on' and motors not moving
  field(OCAL, "C-B")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)Center-SP PP")
}

# Increment width by step
record(bo, "$(P)$(R)IncWidth-Cmd"){
  field(DESC, "Increment width by defined step")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)IncWidthCalc")
}

# Calc to increment width
record(calcout, "$(P)$(R)IncWidthCalc"){
  field(DESC, "Increment width by step calc")
  field(INPA, "$(P)$(R)IncWidth-Cmd")
  field(INPB, "$(P)$(R)WidthStep-RB")
  field(INPC, "$(P)$(R)Width-RB")
  field(INPD, "$(CTRL_NEG)Mtr.DMOV")
  field(INPE, "$(CTRL_POS)Mtr.DMOV")
  field(CALC, "A&&D&&E")                                 # Increment command 'on' and motors not moving
  field(OCAL, "C+B")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)Width-SP PP")
}

# Decrement width by step
record(bo, "$(P)$(R)DecWidth-Cmd"){
  field(DESC, "Decrement width by defined step")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)DecWidthCalc")
}

# Calc to decrement width
record(calcout, "$(P)$(R)DecWidthCalc"){
  field(DESC, "Decrement width by step calc")
  field(INPA, "$(P)$(R)DecWidth-Cmd")
  field(INPB, "$(P)$(R)WidthStep-RB")
  field(INPC, "$(P)$(R)Width-RB")
  field(INPD, "$(CTRL_NEG)Mtr.DMOV")
  field(INPE, "$(CTRL_POS)Mtr.DMOV")
  field(CALC, "A&&D&&E")                                 # Decrement command 'on' and motors not moving
  field(OCAL, "C-B")
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)Width-SP PP")
}

#####################################################################
# INITIALIZATION
#
# Desc: High Level initialization operations.

# One shot operation
record(calcout, "$(P)$(R)OneShot"){
  field(DESC, "One shot operation")
  field(INPA, "1")
  field(INPB, "$(P)$(R)NegativeEdgePos-RB CPP")           # Process when neg edge pos changes
  field(INPC, "$(P)$(R)PositiveEdgePos-RB CPP")          # Process when pos edge pos changes
  field(CALC, "A;A:=0")                               # Only process whole chain one time
  field(OOPT, "When Non-zero")
  field(ODLY, "1")                                    # Wait 1 sec, so that both edges are updated
  field(OUT, "$(P)$(R)GetNegativeEdgeRB.PROC PP")
}

## Initialize coordinate conversion record with
## readback values

# Store neg edge readback value
record(ai, "$(P)$(R)GetNegativeEdgeRB"){
  field(DESC, "Get neg edge pos RB at init")
  field(INP, "$(P)$(R)NegativeEdgePos-RB")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(FLNK, "$(P)$(R)GetPositiveEdgeRB")
}

# Store pos edge readback value
record(ai, "$(P)$(R)GetPositiveEdgeRB"){
  field(DESC, "Get pos edge pos RB at init")
  field(INP, "$(P)$(R)PositiveEdgePos-RB")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(FLNK, "$(P)$(R)UpdateCoordConv")
}

# Sequence to update the coordinate conversion
# record with the position readback values
record(sseq, "$(P)$(R)UpdateCoordConv"){
  field(DESC, "Update coordinate conv record fields")
  field(SELM, "All")
  field(STR1, "Calibrate")
  field(DOL2, "$(P)$(R)GetNegativeEdgeRB")
  field(DOL3, "$(P)$(R)GetPositiveEdgeRB")
  field(STR4, "Move")
  field(LNK1, "$(P)$(R)SetMode-Sel CA")
  field(LNK2, "$(P)$(R)NegativeEdgePos-SP CA")
  field(LNK3, "$(P)$(R)PositiveEdgePos-SP CA")
  field(LNK4, "$(P)$(R)SetMode-Sel CA")
  field(WAIT1, "Wait")
  field(WAIT2, "Wait")
  field(WAIT3, "Wait")
  field(WAIT4, "Wait")
  field(DLY4, "2")                                    # Wait so that pos position is set
  field(FLNK, "$(P)$(R)EnblProtect")
}

# Enable limit protection for both edges
record(seq, "$(P)$(R)EnblProtect"){
  field(DESC, "Disable limit protection for edges")
  field(SELM, "All")
  field(DO1, "1")
  field(DO2, "1")
  field(DO3, "1")
  field(DO4, "1")
  field(LNK1, "$(P)$(R)NegativeEdgeProtect.DISV")         # Enable neg edge limit protection
  field(LNK2, "$(P)$(R)PositiveEdgeProtect.DISV")        # Enable pos edge limit protection
  field(LNK3, "$(P)$(R)NegativeEdgeProtect.PROC PP")      # Process record so it can init limits
  field(LNK4, "$(P)$(R)PositiveEdgeProtect.PROC PP")     # Process record so it can init limits
}

